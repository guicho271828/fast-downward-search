// HACK! Ignore this if used as a top-level compile target.
#ifdef OPEN_LISTS_UCB_LIST_H

#include "bandit_list.h"

#include <iostream>

using namespace std;

template<class Entry>
UCBOpenList<Entry>::UCBOpenList(const Options &opts)
    : BanditOpenList<Entry,UCB>(opts),
      k(opts.get<double>("k")){
    cout << "Initializing UCB openlist with exploration ratio = " << k << endl;
}

template<class Entry>
OpenList<Entry> *UCBOpenList<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("UCB open List", "Adaptive Queue which learns the depth to open next within same f");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    parser.add_option<double>("k", "Exploration ratio k of UCB index \\mu + \\sqrt{ k ln(n)/n_i }. k<0.5 is unsafe.", "0.5");
    parser.add_option<int>("queue", "queue order, 0:fifo,1:lifo,2:random", "1");
    parser.add_option<int>("seed3", "seed for the random generator (for final tiebreaking).", "1");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new UCBOpenList<Entry>(opts);
}

template<class Entry>
RandomDepthOpenList<Entry>::RandomDepthOpenList(const Options &opts)
    : BanditOpenList<Entry,RandomBandit>(opts),
      seed2(opts.get<int>("seed2")){
    cout << "Initializing Random Depth openlist" << endl;
}

template<class Entry>
OpenList<Entry> *RandomDepthOpenList<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("Random Depth open List", "Open depth layers in f-plateau randomly");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    parser.add_option<int>("seed2", "seed for the random generator (for depth tiebreaking).", "1");
    parser.add_option<int>("seed3", "seed for the random generator (for final tiebreaking).", "1");
    parser.add_option<int>("queue", "queue order, 0:fifo,1:lifo,2:random", "1");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new RandomDepthOpenList<Entry>(opts);
}

template<class Entry>
LoopingDepthOpenList<Entry>::LoopingDepthOpenList(const Options &opts)
    : BanditOpenList<Entry,LoopingBandit>(opts){
    cout << "Initializing Looping Depth openlist" << endl;
}

template<class Entry>
OpenList<Entry> *LoopingDepthOpenList<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("Looping Depth open List", "Loop across depth layers in f-plateau");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    parser.add_option<int>("seed3", "seed for the random generator (for final tiebreaking).", "1");
    parser.add_option<int>("queue", "queue order, 0:fifo,1:lifo,2:random", "1");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new LoopingDepthOpenList<Entry>(opts);
}


template<class Entry>
FirstDepthOpenList<Entry>::FirstDepthOpenList(const Options &opts)
    : BanditOpenList<Entry,FirstBandit>(opts){
    cout << "Initializing First Depth openlist" << endl;
}

template<class Entry>
OpenList<Entry> *FirstDepthOpenList<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("First Depth open List", "Open the first depth layers in f-plateau");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    parser.add_option<int>("queue", "queue order, 0:fifo,1:lifo,2:random", "1");
    parser.add_option<int>("seed3", "seed for the random generator (for final tiebreaking).", "1");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new FirstDepthOpenList<Entry>(opts);
}

template<class Entry>
LastDepthOpenList<Entry>::LastDepthOpenList(const Options &opts)
    : BanditOpenList<Entry,LastBandit>(opts){
    cout << "Initializing Last Depth openlist" << endl;
}

template<class Entry>
OpenList<Entry> *LastDepthOpenList<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("Last Depth open List", "Open the last depth layers in f-plateau");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    parser.add_option<int>("queue", "queue order, 0:fifo,1:lifo,2:random", "1");
    parser.add_option<int>("seed3", "seed for the random generator (for final tiebreaking).", "1");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new LastDepthOpenList<Entry>(opts);
}


#endif
