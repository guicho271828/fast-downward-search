// HACK! Ignore this if used as a top-level compile target.
#ifdef OPEN_LISTS_OPEN_TREE2_H

#include "open_tree2.h"
#include <climits>

using namespace std;

template<class Entry>
OpenDTree<Entry>::OpenDTree(const Options &opts)
    : OpenTree<Entry>(opts) {
}

template<class Entry>
const Entry* OpenDTree<Entry>::search_and_cleanup(TreeNode<Entry>* tree) {
    count_cache.clear();
    return OpenTree<Entry>::search_and_cleanup(tree);
}

template<class Entry>
TreeNode<Entry>* OpenDTree<Entry>::search(TreeNode<Entry>* tree) {
    if (tree->entry){
        assert(tree->children.empty());
        return tree;
    } else{
        assert(!tree->children.empty());
        TreeNode<Entry>* min_b = nullptr;
        int min = INT_MAX;
        for (auto branch : tree->children ){
            int count = count_branch(branch);
            if (count < min){
                min = count;
                min_b = branch;
            }
        }
        assert(min_b);
        return search(min_b);
    }
}

template<class Entry>
int OpenDTree<Entry>::count_branch(TreeNode<Entry>* tree) {
    auto found = count_cache.find(tree);
    if(found != count_cache.end()) {
        return found->second;
    }
    if (tree->entry){
        count_cache[tree] = 1;
        return 1;
    } else{
        assert(!tree->children.empty());
        int count = 0;
        for ( auto branch : tree->children) {
            count += count_branch(branch);
        }
        count_cache[tree] = count;
        return count;
    }
}


template<class Entry>
OpenList<Entry> *OpenDTree<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("Open DTree", "Deterministically maintain diversity");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new OpenDTree<Entry>(opts);
}

#endif
