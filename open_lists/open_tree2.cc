// HACK! Ignore this if used as a top-level compile target.
#ifdef OPEN_LISTS_OPEN_TREE2_H

#include "open_tree2.h"
#include <climits>

using namespace std;

template<class Entry>
OpenDTree<Entry>::OpenDTree(const Options &opts)
    : OpenTree<Entry>(opts) {
}

template<class Entry>
TreeNode<Entry>* OpenDTree<Entry>::search(TreeNode<Entry>* tree) {
    if (tree->entry){
        // TODO: if there are children like root-help-help-open(1)-open(2),
        // is it necessary to open (1) and (2) at random?
        return tree;
    }
    else{
        assert(!tree->children.empty());
        TreeNode<Entry>* min_b = nullptr;
        int min = INT_MAX;
        for (auto branch : tree->children ){
            int count = count_branch(branch);
            if (count < min){
                min = count;
                min_b = branch;
            }
        }
        assert(min_b);
        return search(min_b);
    }
}

template<class Entry>
int OpenDTree<Entry>::count_branch(TreeNode<Entry>* tree) {
    if (tree->entry){
        return 1;
    } else{
        assert(!tree->children.empty());
        int count = 0;
        for ( auto branch : tree->children) {
            count += count_branch(branch);
        }
        return count;
    }
}


template<class Entry>
OpenList<Entry> *OpenDTree<Entry>::_parse(OptionParser &parser) {
    parser.document_synopsis("Open DTree", "Deterministically maintain diversity");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "false");
    parser.add_option<bool>("frontier", "Print the size of the frontier when new one is visited", "false");
    Options opts = parser.parse();
    if (parser.dry_run())
        return 0;
    else
        return new OpenDTree<Entry>(opts);
}

#endif
